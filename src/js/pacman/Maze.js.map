{"version":3,"sources":["../app/pacman/Maze.ts"],"names":[],"mappings":"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","file":"Maze.js","sourcesContent":["module pacman {\r\n    'use strict';\r\n\r\n    let DOT_POINTS: number[] = [ 50, 10 ];\r\n\r\n    export class Maze {\r\n\r\n        private _data: number[][];\r\n        private _mazeCanvas: HTMLCanvasElement;\r\n        private _eatenDotCount: number;\r\n        private _dotCount: number;\r\n        private _origMazeInfo: number[][];\r\n\r\n        closed: MazeNode[] = [];\r\n        open: MazeNode[] = [];\r\n        goalNode: MazeNode = new MazeNode();\r\n\r\n        /**\r\n         * A cache of nodes to speed up search operations.\r\n         */\r\n        private _nodeCache: gtp.Pool<MazeNode>;\r\n\r\n        constructor(mazeInfo: number[][]) {\r\n            this._data = [];\r\n            this.reset(mazeInfo);\r\n        }\r\n\r\n        private static _cloneObjectOfPrimitives(obj: any): any {\r\n            return JSON.parse(JSON.stringify(obj));\r\n        }\r\n\r\n        /**\r\n         * Checks whether a dot is in the maze at the specified location.  If\r\n         * it is, it is removed.  If a dot is removed, the points the player should\r\n         * receive is returned.\r\n         *\r\n         * @param {number} row The row to check.\r\n         * @param {number} col The column to check.\r\n         * @return {number} The amount to add to the player's score, if any.\r\n         */\r\n        checkForDot(row: number, col: number): number {\r\n\r\n            let score: number = 0;\r\n            let tile: number = this._getTileAt(row, col);\r\n\r\n            if (tile >= 0xfe) { // Small dot or big dot.\r\n                game.playChompSound();\r\n                if (tile === 0xfe) {\r\n                    game.makeGhostsBlue();\r\n                }\r\n                this._eatenDotCount++;\r\n                this._data[row][col] = 0;\r\n                score = DOT_POINTS[tile - 0xfe];\r\n                if (this._eatenDotCount === Maze.FRUIT_DOT_COUNT) {\r\n                    game.addFruit();\r\n                }\r\n                if (this._eatenDotCount === this._dotCount) {\r\n                    game.loadNextLevel();\r\n                }\r\n            }\r\n\r\n            return score;\r\n        }\r\n\r\n        /**\r\n         * Returns the next node an object should move to if they want to take\r\n         * the shortest route possible to the destination.\r\n         *\r\n         * @param node The linked list of nodes in the path to the destination,\r\n         *        in reverse order.  This list should have been obtained from a\r\n         *        breadth-first search.\r\n         * @return The first node to move to.\r\n         */\r\n        private static _constructPath(node: MazeNode): MazeNode/*MazeNode[]*/ {\r\n            /*\r\n             LinkedList<Node> path = new LinkedList<Node>();\r\n             while (node.parent!=null) {\r\n             path.addFirst(node);\r\n             node = node.parent;\r\n             }\r\n             return path;\r\n             */\r\n            let prev: MazeNode = null;\r\n            while (node.parent) {\r\n                prev = node;\r\n                node = node.parent;\r\n            }\r\n            return prev;\r\n        }\r\n\r\n        /**\r\n         * Returns the number of dots Pacman must eat before a fruit appears.\r\n         *\r\n         * @return {number} The number of dots Pacman must eat.\r\n         */\r\n        static get FRUIT_DOT_COUNT(): number {\r\n            return 64;\r\n        }\r\n\r\n        /**\r\n         * Returns the \"next\" column, taking wrapping (from the tunnels) into\r\n         * account.\r\n         *\r\n         * @param {number} col The current column.\r\n         * @return {number} The column to the \"right\" of <code>col</code>.\r\n         * @see getPreviousColumn\r\n         */\r\n        private static _getNextColumn(col: number): number {\r\n            if (++col === Maze.TILE_COUNT_HORIZONTAL) {\r\n                col = 0;\r\n            }\r\n            return col;\r\n        }\r\n\r\n        getPathBreadthFirst(fromRow: number, fromCol: number, toRow: number,\r\n                            toCol: number): MazeNode {\r\n\r\n            let self: Maze = this;\r\n            this.open.forEach((node: MazeNode) => {\r\n                self._data[node.row][node.col] &= 0xff;\r\n            });\r\n            this.closed.forEach((node: MazeNode) => {\r\n                self._data[node.row][node.col] &= 0xff;\r\n            });\r\n\r\n            this.open.length = 0;\r\n            this.closed.length = 0;\r\n            this.goalNode.set(toRow, toCol, null);\r\n            let temp: MazeNode = this._nodeCache.borrowObj();\r\n\r\n            //path.add(computeInt(fromRow, fromCol));\r\n            this.open.push(new MazeNode(fromRow, fromCol));\r\n            this._data[fromRow][fromCol] |= 0x100;\r\n\r\n            while (this.open.length > 0) {\r\n\r\n                let node: MazeNode = this.open.splice(0, 1)[0];\r\n                if (node.equals(this.goalNode)) {\r\n                    this._data[node.row][node.col] &= 0xff; // Won't be in open or closed lists\r\n                    return Maze._constructPath(node);\r\n                }\r\n\r\n                else {\r\n\r\n                    this.closed.push(node);\r\n\r\n                    // Add neighbors to the open list\r\n                    if (this.isWalkable(node.row - 1, node.col)) {\r\n                        //temp.set(node.row - 1, node.col);\r\n                        //if (!this.closed.contains(temp) && !this.open.contains(temp)) {\r\n                        //   temp.parent = node;\r\n                        //}\r\n                        if ((this._data[node.row - 1][node.col] & 0x100) === 0) {\r\n                            this._data[node.row - 1][node.col] |= 0x100;\r\n                            temp.set(node.row - 1, node.col, node);\r\n                            this.open.push(temp);\r\n                            temp = this._nodeCache.borrowObj();\r\n                        }\r\n                    }\r\n\r\n                    if (this.isWalkable(node.row + 1, node.col)) {\r\n                        //temp.set(node.row + 1, node.col);\r\n                        //if (!this.closed.contains(temp) && !this.open.contains(temp)) {\r\n                        //   temp.parent = node;\r\n                        //}\r\n                        if ((this._data[node.row + 1][node.col] & 0x100) === 0) {\r\n                            this._data[node.row + 1][node.col] |= 0x100;\r\n                            temp.set(node.row + 1, node.col, node);\r\n                            this.open.push(temp);\r\n                            temp = this._nodeCache.borrowObj();\r\n                        }\r\n                    }\r\n\r\n                    let col: number = Maze._getPreviousColumn(node.col);\r\n                    if (this.isWalkable(node.row, col)) {\r\n                        //temp.set(node.row, col);\r\n                        //if (!this.closed.contains(temp) && !this.open.contains(temp)) {\r\n                        //   temp.parent = node;\r\n                        //}\r\n                        if ((this._data[node.row][col] & 0x100) === 0) {\r\n                            this._data[node.row][col] |= 0x100;\r\n                            temp.set(node.row, col, node);\r\n                            this.open.push(temp);\r\n                            temp = this._nodeCache.borrowObj();\r\n                        }\r\n                    }\r\n\r\n                    col = Maze._getNextColumn(node.col);\r\n                    if (this.isWalkable(node.row, col)) {\r\n                        //temp.set(node.row, col);\r\n                        //if (!this.closed.contains(temp) && !this.open.contains(temp)) {\r\n                        //   temp.parent = node;\r\n                        //}\r\n                        if ((this._data[node.row][col] & 0x100) === 0) {\r\n                            this._data[node.row][col] |= 0x100;\r\n                            temp.set(node.row, col, node);\r\n                            this.open.push(temp);\r\n                            temp = this._nodeCache.borrowObj();\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            // No path found - should never happen\r\n            throw new Error('No path found from (' + fromRow + ', ' + fromCol +\r\n                ') to (' + toRow + ', ' + toCol + ')');\r\n        }\r\n\r\n        /**\r\n         * Returns the \"previous\" column, taking wrapping (from the tunnels) into\r\n         * account.\r\n         *\r\n         * @param {number} col The current column.\r\n         * @return {number} The column to the \"left\" of <code>col</code>.\r\n         * @see getNextColumn\r\n         */\r\n        private static _getPreviousColumn(col: number): number {\r\n            if (col === 0) {\r\n                col = Maze.TILE_COUNT_HORIZONTAL;\r\n            }\r\n            return col - 1;\r\n        }\r\n\r\n        static get TILE_COUNT_HORIZONTAL(): number {\r\n            return 28;\r\n        }\r\n\r\n        static get TILE_COUNT_VERTICAL(): number {\r\n            return 32;\r\n        }\r\n\r\n        static get TILE_DOT_BIG(): number {\r\n            return 0xfe;\r\n        }\r\n\r\n        static get TILE_DOT_SMALL(): number {\r\n            return 0xff;\r\n        }\r\n\r\n        /**\r\n         * Returns the tile at the specified location.\r\n         *\r\n         * @param {int} row The row to check.\r\n         * @param {int} col The column to check.\r\n         * @return {int} The row data.\r\n         */\r\n        private _getTileAt(row: number, col: number): number {\r\n            // Forgive bounds errors in case the user is going through the tunnel.\r\n            if (col < 0 || col >= Maze.TILE_COUNT_HORIZONTAL) {\r\n                return -1;\r\n            }\r\n            if (row < 0 || row >= Maze.TILE_COUNT_VERTICAL) {\r\n                return -1;\r\n            }\r\n            return this._data[row][col] & 0xff; // Remove internally-used high bits\r\n        }\r\n\r\n        isClearShotColumn(col: number, row1: number, row2: number): boolean {\r\n            let start: number = Math.min(row1, row2);\r\n            let end: number = Math.max(row1, row2);\r\n            for (let i: number = start + 1; i < end; i++) {\r\n                if (!this.isWalkable(i, col)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        isClearShotRow(row: number, col1: number, col2: number): boolean {\r\n            let start: number = Math.min(col1, col2);\r\n            let end: number = Math.max(col1, col2);\r\n            for (let i: number = start + 1; i < end; i++) {\r\n                if (!this.isWalkable(row, i)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * Returns whether a sprite can move onto the specified tile.\r\n         * @param {number} row The row to check.\r\n         * @param {number} col The column to check.\r\n         * @return {boolean} Whether a sprite can walk ono the specified tile.\r\n         */\r\n        isWalkable(row: number, col: number): boolean {\r\n            let tile: number = this._getTileAt(row, col);\r\n            return tile === 0 || tile >= 0xf0;\r\n        }\r\n\r\n        render(ctx: CanvasRenderingContext2D) {\r\n\r\n            // Draw all static content\r\n            ctx.drawImage(this._mazeCanvas, 0, 0);\r\n\r\n            let TILE_SIZE: number = 8;\r\n\r\n            // Draw the dots\r\n            ctx.fillStyle = '#ffffff';\r\n            for (let row: number = 0; row < Maze.TILE_COUNT_VERTICAL; row++) {\r\n\r\n                let y: number = row * TILE_SIZE + (2 * TILE_SIZE);\r\n\r\n                for (let col: number = 0; col < Maze.TILE_COUNT_HORIZONTAL; col++) {\r\n\r\n                    let tile: number = this._getTileAt(row, col);\r\n                    let x: number = col * TILE_SIZE;\r\n\r\n                    if (tile === Maze.TILE_DOT_SMALL) {\r\n                        game.drawSmallDot(x + 3, y + 2);\r\n                    }\r\n                    else if (tile === Maze.TILE_DOT_BIG) {\r\n                        game.drawBigDot(x, y);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Resets this maze.\r\n         * @param mazeInfo The raw data for this maze.  If this is undefined, it\r\n         *        is assumed that we are simply resetting to load a new level.\r\n         */\r\n        reset(mazeInfo?: number[][]) {\r\n            'use strict';\r\n\r\n            let TILE_SIZE: number = PacmanGame.TILE_SIZE;\r\n            let firstTime: boolean = mazeInfo != null;\r\n\r\n            // Load (or reset) map data\r\n            if (firstTime) {\r\n                // First time through, we cache a pristine view of our maze data\r\n                this._origMazeInfo = Maze._cloneObjectOfPrimitives(mazeInfo);\r\n            }\r\n            // Next, we create a working copy of our maze data, since we mutate it\r\n            this._data = Maze._cloneObjectOfPrimitives(this._origMazeInfo);\r\n            this._eatenDotCount = 0;\r\n\r\n            if (firstTime) {\r\n\r\n                const mapTiles: gtp.SpriteSheet = game.assets.get('mapTiles');\r\n\r\n                // Create an image for the maze\r\n                const mazeY: number = 2 * TILE_SIZE;\r\n                this._mazeCanvas = gtp.ImageUtils.createCanvas(game.getWidth(), game.getHeight());\r\n                const mazeCtx: CanvasRenderingContext2D = this._mazeCanvas.getContext('2d');\r\n                let walkableCount: number = 0;\r\n                this._dotCount = 0;\r\n\r\n                mazeCtx.fillStyle = '#000000';\r\n                mazeCtx.fillRect(0, 0, this._mazeCanvas.width, this._mazeCanvas.height);\r\n\r\n                game.drawScoresHeaders(mazeCtx);\r\n\r\n                // Render each tile from the map data\r\n                for (let row: number = 0; row < this._data.length; row++) {\r\n\r\n                    const rowData: number[] = this._data[row];\r\n\r\n                    for (let col: number = 0; col < rowData.length; col++) {\r\n\r\n                        let tile: number = rowData[col];\r\n                        if (tile === 0 || tile >= 0xf0) {\r\n                            walkableCount++;\r\n                        }\r\n\r\n                        switch (tile) {\r\n\r\n                            case Maze.TILE_DOT_SMALL:\r\n                            case Maze.TILE_DOT_BIG:\r\n                                this._dotCount++;\r\n                                break;\r\n\r\n                            default:\r\n                                tile--;\r\n                                if (tile > -1) {\r\n                                    let dx: number = col * TILE_SIZE;\r\n                                    let dy: number = mazeY + row * TILE_SIZE;\r\n                                    mapTiles.drawByIndex(mazeCtx, dx, dy, tile);\r\n                                }\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!this._nodeCache) {\r\n                    this._nodeCache = new gtp.Pool(MazeNode, walkableCount);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"]}