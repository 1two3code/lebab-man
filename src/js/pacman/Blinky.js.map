{"version":3,"sources":["pacman/Blinky.ts"],"names":["pacman","pacman.Blinky","pacman.Blinky.constructor","pacman.Blinky.reset","pacman.Blinky.updatePositionChasingPacman"],"mappings":";;;;;AAAA,IAAO,MAAM,CA2FZ;AA3FD,WAAO,MAAM,EAAC,CAAC;IACbA,YAAYA,CAACA;IAEXA;;;OAGGA;IACFA;QAA4BC,0BAAKA;QAEjCA;;WAEGA;QACHA,gBAAYA,IAAgBA;YAC3BC,kBAAMA,IAAIA,EAAEA,CAACA,GAAGA,IAAIA,CAACA,WAAWA,EAAEA,CAACA,CAACA,CAACA,CAACA,mCAAmCA;QAC1EA,CAACA;QAEDD;;;;;;;;;;WAUGA;QACHA,sBAAKA,GAALA;YACCE,gBAAKA,CAACA,KAAKA,WAAEA,CAACA;YACdA,IAAIA,CAACA,SAASA,GAAGA,gBAASA,CAACA,IAAIA,CAACA;YAChCA,IAAIA,CAACA,WAAWA,CAACA,IAAIA,CAACA,IAAIA,CAACA,kBAAkBA,EAAEA,IAAIA,CAACA,IAAIA,CAACA,kBAAkBA,CAACA,CAACA;YAC7EA,IAAIA,CAACA,WAAWA,GAAGA,kBAAWA,CAACA,UAAUA,CAACA;QAC3CA,CAACA;QAEHF;;;;WAIGA;QACHA,4CAA2BA,GAA3BA,UAA4BA,IAAUA;YAErCG,SAASA;YACTA,oEAAoEA;YACpEA,6CAA6CA;YAE7CA,4CAA4CA;YAC1CA,EAAEA;YACJA,0DAA0DA;YACxDA,EAAEA;YACJA,mCAAmCA;YACnCA,sCAAsCA;YACtCA,oDAAoDA;YACpDA,uDAAuDA;YACvDA,kFAAkFA;YAChFA,EAAEA;YACJA,8DAA8DA;YAC9DA,wCAAwCA;YACxCA,KAAKA;YACLA,gCAAgCA;YAChCA,qCAAqCA;YACrCA,4BAA4BA;YAC5BA,KAAKA;YACLA,gCAAgCA;YAChCA,qCAAqCA;YACrCA,2BAA2BA;YAC3BA,KAAKA;YACLA,gCAAgCA;YAChCA,sCAAsCA;YACtCA,4BAA4BA;YAC5BA,KAAKA;YACLA,gCAAgCA;YAChCA,sCAAsCA;YACtCA,2BAA2BA;YAC3BA,KAAKA;YACHA,EAAEA;YACJA,IAAIA;YACFA,EAAEA;YACJA,gEAAgEA;YAChEA,+BAA+BA;YAC/BA,SAASA;YACTA,gDAAgDA;YAChDA,IAAIA;YACFA,EAAEA;YACJA,wDAAwDA;YACxDA,mDAAmDA;YACjDA,+CAA+CA;YACjDA,IAAIA;QAELA,CAACA;QAEFH,aAACA;IAADA,CAnFGD,AAmFFC,EAnF8BD,YAAKA,EAmFnCA;IAnFeA,aAAMA,SAmFrBA,CAAAA;AACHA,CAACA,EA3FM,MAAM,KAAN,MAAM,QA2FZ","file":"pacman/Blinky.js","sourcesContent":["module pacman {\r\n  'use strict';\r\n\r\n    /**\r\n     * Blinky, the red ghost.  Blinky always takes the shortest route to Pacman\r\n     * when chasing him.\r\n     */\r\n     export class Blinky extends Ghost {\r\n\r\n    \t/**\r\n    \t * Constructor.\r\n    \t */\r\n    \tconstructor(game: PacmanGame) {\r\n    \t\tsuper(game, 0 * game.SPRITE_SIZE, 0); // Not initially in the penalty box\r\n    \t}\r\n\r\n    \t/**\r\n    \t * Resets the ghost's internal state so that:\r\n    \t *\r\n    \t * <ol>\r\n    \t *    <li>It is in the penalty box (except for Blinky).\r\n    \t *    <li>It's no longer blinking.\r\n    \t *    <li>Its direction is set appropriately.\r\n    \t * </ol>\r\n    \t *\r\n    \t * This method should be called on loading a new level, PacMan dying, etc.\r\n    \t */\r\n    \treset() {\r\n    \t\tsuper.reset();\r\n    \t\tthis.direction = Direction.WEST;\r\n    \t\tthis.setLocation(this.game.PENALTY_BOX_EXIT_X, this.game.PENALTY_BOX_EXIT_Y);\r\n    \t\tthis.motionState = MotionState.SCATTERING;\r\n    \t}\r\n\r\n  \t/**\r\n  \t * Updates an actor's position.\r\n  \t *\r\n  \t * @param maze The maze in which the actor is moving.\r\n  \t */\r\n  \tupdatePositionChasingPacman(maze: Maze) {\r\n\r\n  \t\t// Logic:\r\n  \t\t// If at an intersection, do a breadth-first search for the shortest\r\n  \t\t// route to PacMan, and go in that direction.\r\n\r\n  \t\t// let moveAmount: number = getMoveAmount();\r\n      //\r\n  \t\t// if (atIntersection(maze)) { // If the ghost can turn...\r\n      //\r\n  \t\t// \tlet fromRow: number = getRow();\r\n  \t\t// \tlet fromCol: number = getColumn();\r\n  \t\t// \tlet toRow: number = engine.getPacMan().getRow();\r\n  \t\t// \tlet toCol: number = engine.getPacMan().getColumn();\r\n  \t\t// \tlet node: MazeNode = maze.getPathBreadthFirst(fromRow, fromCol, toRow, toCol);\r\n      //\r\n  \t\t// \tif (node==null) { // Happens only with \"God Mode\" enabled.\r\n  \t\t// \t\tthis.changeDirectionFallback(maze);\r\n  \t\t// \t}\r\n  \t\t// \telse if (node.col<fromCol) {\r\n  \t\t// \t\tthis.direction = Direction.WEST;\r\n  \t\t// \t\tthis.incX(-moveAmount);\r\n  \t\t// \t}\r\n  \t\t// \telse if (node.col>fromCol) {\r\n  \t\t// \t\tthis.direction = Direction.EAST;\r\n  \t\t// \t\tthis.incX(moveAmount);\r\n  \t\t// \t}\r\n  \t\t// \telse if (node.row<fromRow) {\r\n  \t\t// \t\tthis.direction = Direction.NORTH;\r\n  \t\t// \t\tthis.incY(-moveAmount);\r\n  \t\t// \t}\r\n  \t\t// \telse if (node.row>fromRow) {\r\n  \t\t// \t\tthis.direction = Direction.SOUTH;\r\n  \t\t// \t\tthis.incY(moveAmount);\r\n  \t\t// \t}\r\n      //\r\n  \t\t// }\r\n      //\r\n  \t\t// // Not at an intersection, so we should be able to keep going\r\n  \t\t// // in our current direction.\r\n  \t\t// else {\r\n  \t\t// \tthis.continueInCurrentDirection(moveAmount);\r\n  \t\t// }\r\n      //\r\n  \t\t// // Switch over to scatter mode if it's time to do so.\r\n  \t\t// if (game.playTime >= this.startScatteringTime) {\r\n      //   this.motionState = MotionState.SCATTERING;\r\n  \t\t// }\r\n\r\n  \t}\r\n\r\n  }\r\n}\r\n"],"sourceRoot":"/source/"}