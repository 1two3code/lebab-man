{"version":3,"sources":["../app/pacman/Ghost.ts"],"names":[],"mappings":"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","file":"Ghost.js","sourcesContent":["module pacman {\r\n    'use strict';\r\n\r\n    const GHOST_IN_BOX_SPEED: number = 0.5;\r\n\r\n    export enum MotionState {\r\n        IN_BOX = 0,\r\n        LEAVING_BOX = 1,\r\n        CHASING_PACMAN = 2,\r\n        SCATTERING = 3,\r\n        BLUE = 4,\r\n        EYES = 5,\r\n        EYES_ENTERING_BOX = 6\r\n    }\r\n\r\n    export abstract class Ghost extends _BaseSprite {\r\n\r\n        /**\r\n         * TODO: Remove the need for this variable!  Yucky!\r\n         */\r\n        game: PacmanGame;\r\n\r\n        /**\r\n         * The ghost's current motion state.\r\n         */\r\n        private _motionState: MotionState;\r\n\r\n        /**\r\n         * The \"corner\" this ghost will retreat to when in \"scatter\" mode.\r\n         */\r\n        private _corner: gtp.Point;\r\n\r\n        /**\r\n         * The number of times this ghost has been in \"scatter\" mode for this\r\n         * level and PacMan life.\r\n         */\r\n        private _scatterCount: number;\r\n\r\n        /**\r\n         * If in scatter mode, this is the time at which the mode should switch\r\n         * to \"chasing PacMan\" mode.  If not in scatter mode, this value is\r\n         * invalid.\r\n         */\r\n        private _exitScatteringTime: number;\r\n\r\n        /**\r\n         * The time at which this ghost should switch from \"chasing PacMan\" mode\r\n         * to scatter mode.  If not in the \"chasing PacMan\" motion state,\r\n         * this value is invalid.\r\n         */\r\n        startScatteringTime: number;\r\n\r\n        /**\r\n         * The time at which a ghost should switch from \"blue mode\" to their\r\n         * previous state (chasing PacMan or scattering).  If not in the \"blue\"\r\n         * motion state, this value is invalid.\r\n         */\r\n        exitBlueTime: number;\r\n\r\n        /**\r\n         * The motion state to revert back to when a ghost leaves \"blue mode.\"\r\n         * If a ghost is not in \"blue mode,\" this value is invalid.\r\n         */\r\n        private _previousState: number;\r\n\r\n        /**\r\n         * The y-coordinate of the sprites in the sprite sheet to use.\r\n         */\r\n        private _spriteSheetY: number;\r\n\r\n        /**\r\n         * The number of seconds this ghost will wait before leaving the penalty\r\n         * box for the first time.\r\n         */\r\n        private _exitDelaySeconds: number;\r\n\r\n        constructor(game: PacmanGame, spriteSheetY: number, exitDelaySeconds: number) {\r\n            super(2);\r\n            this.game = game;\r\n            this._corner = new gtp.Point();\r\n            this._spriteSheetY = spriteSheetY;\r\n            this._exitDelaySeconds = exitDelaySeconds;\r\n            this.reset();\r\n        }\r\n\r\n        changeDirectionFallback(maze: Maze) {\r\n\r\n            const moveAmount: number = this.moveAmount;\r\n            const temp: number = gtp.Utils.randomInt(4);\r\n\r\n            switch (temp) {\r\n\r\n                case 0:\r\n                    if (!this.goUpIfPossible(maze, moveAmount)) {\r\n                        if (!this.goLeftIfPossible(maze, moveAmount)) {\r\n                            if (!this.goRightIfPossible(maze, moveAmount)) {\r\n                                this.goDownIfPossible(maze, moveAmount);\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n\r\n                case 1:\r\n                    if (!this.goLeftIfPossible(maze, moveAmount)) {\r\n                        if (!this.goUpIfPossible(maze, moveAmount)) {\r\n                            if (!this.goDownIfPossible(maze, moveAmount)) {\r\n                                this.goRightIfPossible(maze, moveAmount);\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n\r\n                case 2:\r\n                    if (!this.goDownIfPossible(maze, moveAmount)) {\r\n                        if (!this.goLeftIfPossible(maze, moveAmount)) {\r\n                            if (!this.goRightIfPossible(maze, moveAmount)) {\r\n                                this.goUpIfPossible(maze, moveAmount);\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n\r\n                case 3:\r\n                    if (!this.goRightIfPossible(maze, moveAmount)) {\r\n                        if (!this.goUpIfPossible(maze, moveAmount)) {\r\n                            if (!this.goDownIfPossible(maze, moveAmount)) {\r\n                                this.goLeftIfPossible(maze, moveAmount);\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n\r\n        }\r\n\r\n        /**\r\n         * Moves this ghost in its current direction by the specified amount.\r\n         *\r\n         * @param {number} moveAmount The amount to move.\r\n         */\r\n        continueInCurrentDirection(moveAmount: number) {\r\n            switch (this.direction) {\r\n                case Direction.NORTH:\r\n                    this.incY(-moveAmount);\r\n                    break;\r\n                case Direction.WEST:\r\n                    this.incX(-moveAmount);\r\n                    break;\r\n                case Direction.SOUTH:\r\n                    this.incY(moveAmount);\r\n                    break;\r\n                case Direction.EAST:\r\n                    this.incX(moveAmount);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns the length of play time a ghost should stay blue, in\r\n         * milliseconds.\r\n         *\r\n         * @param {number} level The current game level.\r\n         * @return {numbe} The length of time a ghost should stay blue.\r\n         */\r\n        private _getBlueTimeForLevel(level: number): number {\r\n            switch (level) {\r\n                case 0:\r\n                case 1:\r\n                    return 8000;\r\n                case 2:\r\n                case 3:\r\n                    return 6000;\r\n                case 4:\r\n                case 5:\r\n                    return 4000;\r\n                case 6:\r\n                case 7:\r\n                    return 2000;\r\n                default:\r\n                    return 0;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns the amount of time, in milliseconds, that this ghost will wait\r\n         * for before leaving the penalty box for the first time.\r\n         *\r\n         * @return {number} The delay, in milliseconds.\r\n         */\r\n        private _getFirstExitDelayMillis(): number {\r\n            return this._exitDelaySeconds * 1000;\r\n        }\r\n\r\n        getFrameCount(): number {\r\n            return 2;\r\n        }\r\n\r\n        get motionState(): MotionState {\r\n            return this._motionState;\r\n        }\r\n\r\n        /**\r\n         * Returns the number of milliseconds that should pass between the times\r\n         * this ghost moves.  This value is dependant on the ghost's current\r\n         * state.\r\n         *\r\n         * @return The update delay, in milliseconds.\r\n         */\r\n        getUpdateDelayMillis(): number {\r\n            switch (this._motionState) {\r\n                case MotionState.BLUE:\r\n                    return 25;\r\n                case MotionState.EYES:\r\n                case MotionState.EYES_ENTERING_BOX:\r\n                    return 10;\r\n                default: // Chasing PacMan, in penalty box, etc.\r\n                    return 10;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns whether this ghost is in a \"blue\" motion state.\r\n         *\r\n         * @return {boolean} Whether this ghost is blue.\r\n         * @see #isEyes()\r\n         */\r\n        isBlue(): boolean {\r\n            return this._motionState === MotionState.BLUE;\r\n        }\r\n\r\n        /**\r\n         * Returns whether this ghost is in a \"eyes\" motion state.\r\n         *\r\n         * @return Whether this ghost is in an \"eyes\" state.\r\n         * @see #isBlue()\r\n         */\r\n        isEyes(): boolean {\r\n            return this._motionState === MotionState.EYES ||\r\n                this._motionState === MotionState.EYES_ENTERING_BOX;\r\n        }\r\n\r\n        /**\r\n         * Paints this sprite at its current location.\r\n         *\r\n         * @param {CanvasRenderingContext2D} ctx The rendering context to use.\r\n         */\r\n        paint(ctx: CanvasRenderingContext2D) {\r\n\r\n            let destX: number = this.bounds.x;\r\n            let destY: number = this.bounds.y;\r\n            let SPRITE_SIZE: number = PacmanGame.SPRITE_SIZE;\r\n            let srcX: number,\r\n                srcY: number;\r\n\r\n            switch (this._motionState) {\r\n\r\n                case MotionState.BLUE:\r\n                    srcX = (10 + this.getFrame()) * SPRITE_SIZE;\r\n                    srcY = 3 * SPRITE_SIZE;\r\n                    let playTime: number = game.playTime;\r\n                    if ((this.exitBlueTime - playTime) <= 1000) { // 1 sec. remaining\r\n                        if (((playTime / 250) & 1) !== 0) {\r\n                            srcY += SPRITE_SIZE; // Flash 4 times in last second\r\n                        }\r\n                    }\r\n                    game.drawSprite(destX, destY, srcX, srcY);\r\n                    break;\r\n\r\n                case MotionState.EYES:\r\n                case MotionState.EYES_ENTERING_BOX:\r\n                    srcX = this.direction * SPRITE_SIZE;\r\n                    srcY = 4 * SPRITE_SIZE;\r\n                    game.drawSprite(destX, destY, srcX, srcY);\r\n                    break;\r\n\r\n                default:\r\n                    srcX = this.direction * SPRITE_SIZE * this.getFrameCount() +\r\n                        this.getFrame() * SPRITE_SIZE;\r\n                    srcY = this._spriteSheetY;\r\n                    game.drawSprite(destX, destY, srcX, srcY);\r\n                    break;\r\n\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Turns this ghost \"blue,\" if it is not in the penalty box and is not\r\n         * currently floating eyes.\r\n         */\r\n        possiblyTurnBlue(): boolean {\r\n            switch (this._motionState) {\r\n                case MotionState.CHASING_PACMAN:\r\n                case MotionState.SCATTERING:\r\n                case MotionState.BLUE:\r\n                    this.motionState = MotionState.BLUE;\r\n                    return true;\r\n                default:\r\n                    // Do nothing; in other states, we don't turn blue.\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Resets the ghost's internal state so that:\r\n         *\r\n         * <ol>\r\n         *    <li>It is in the penalty box (except for Blinky).\r\n         *    <li>It's no longer blinking.\r\n         *    <li>Its direction is set appropriately.\r\n         * </ol>\r\n         *\r\n         * This method should be called on loading a new level, PacMan dying, etc.\r\n         * Subclasses should be sure to call the super's implementation when\r\n         * overriding.\r\n         */\r\n        reset() {\r\n            super.reset();\r\n            this._scatterCount = 0;\r\n        }\r\n\r\n        /**\r\n         * Sets the coordinates of the \"corner\" this ghost goes to when in scatter\r\n         * mode.\r\n         *\r\n         * @param {gtp.Point} corner The corner to go to.\r\n         */\r\n        setCorner(corner: gtp.Point) {\r\n            this._corner.x = corner.x;\r\n            this._corner.y = corner.y;\r\n        }\r\n\r\n        set motionState(motionState: MotionState) {\r\n\r\n            let game: PacmanGame = this.game;\r\n\r\n            // Ghosts stay in \"scatter mode\" for varying lengths of time:\r\n            // The first (just out of the penalty box) and second times, it lasts\r\n            // for 7 seconds.  The third and fourth times, it lasts for 5 seconds.\r\n            // Ghosts don't enter scatter mode a 5th time; they just relentlessly\r\n            // attack PacMan.\r\n            if (motionState === MotionState.SCATTERING) {\r\n                switch (this._scatterCount++) {\r\n                    case 0:\r\n                    case 1:\r\n                        this._exitScatteringTime = game.playTime + 7000;\r\n                        this._motionState = motionState;\r\n                        break;\r\n                    case 2:\r\n                    case 3:\r\n                        this._exitScatteringTime = game.playTime + 5000;\r\n                        this._motionState = motionState;\r\n                        break;\r\n                    default:\r\n                        this._motionState = MotionState.CHASING_PACMAN;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            else if (motionState === MotionState.BLUE) {\r\n                let blueTime: number  = this._getBlueTimeForLevel(game.level);\r\n                let playTime: number = game.playTime;\r\n                this.exitBlueTime = playTime + blueTime;\r\n                // Remember previous state and modify its \"end time\" to\r\n                // include the blue time.\r\n                switch (this._motionState) {\r\n                    case MotionState.CHASING_PACMAN:\r\n                        this._previousState = this._motionState;\r\n                        this.startScatteringTime += blueTime;\r\n                        break;\r\n                    case MotionState.SCATTERING:\r\n                        this._previousState = this._motionState;\r\n                        this._exitScatteringTime += blueTime;\r\n                        break;\r\n                    case MotionState.BLUE:\r\n                        // Keep previous \"previousState\".\r\n                        let prevBlueTimeRemaining: number = this.exitBlueTime - playTime;\r\n                        switch (this._previousState) {\r\n                            case MotionState.CHASING_PACMAN:\r\n                                this.startScatteringTime += prevBlueTimeRemaining + blueTime;\r\n                                break;\r\n                            case MotionState.SCATTERING:\r\n                                this._exitScatteringTime += prevBlueTimeRemaining + blueTime;\r\n                                break;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        throw  new Error('Unexpected state: ' + this._motionState);\r\n                }\r\n                this._motionState = motionState;\r\n            }\r\n\r\n            // Any states other than \"scatter mode\" and \"blue\" aren't special.\r\n            else {\r\n                if (this._motionState === MotionState.CHASING_PACMAN) {\r\n                    this.startScatteringTime = game.playTime + 20000;\r\n                }\r\n                this._motionState = motionState;\r\n            }\r\n\r\n            this.game.checkLoopedSound();\r\n        }\r\n\r\n        /**\r\n         * Updates this ghost's position when they are \"blue.\"\r\n         *\r\n         * @param {Maze} maze The maze in which the ghost is moving.\r\n         */\r\n        _updatePositionBlue(maze: Maze) {\r\n\r\n            // Logic:\r\n            // If PacMan has a clear shot to us, try to go in a direction other\r\n            // than PacMan before resorting to going straight for him.  If\r\n            // PacMan does NOT have a clear shot, just pick a random direction.\r\n\r\n            let moveAmount: number = this.moveAmount;\r\n\r\n            // If we're at an intersection and can change direction...\r\n            if (this.atIntersection(maze)) {\r\n\r\n                let pacman: Pacman = game.pacman;\r\n                let pacRow: number = pacman.row;\r\n                let pacCol: number = pacman.column;\r\n                let row: number = this.row;\r\n                let col: number = this.column;\r\n                let moved: boolean = false;\r\n\r\n                // If PacMan has a straight shot to us in our row, try to go\r\n                // in a direction other than towards PacMan.\r\n                if (row === pacRow && maze.isClearShotRow(row, col, pacCol)) {\r\n                    if (!this.goUpIfPossible(maze, moveAmount)) {\r\n                        if (!this.goDownIfPossible(maze, moveAmount)) {\r\n                            if (pacCol < col) { // PacMan is to our left.\r\n                                if (!this.goRightIfPossible(maze, moveAmount)) {\r\n                                    this.direction = Direction.WEST;\r\n                                    this.incX(-moveAmount); // Must go towards PacMan.\r\n                                }\r\n                            }\r\n                            else { // PacMan is to our right.\r\n                                if (!this.goLeftIfPossible(maze, moveAmount)) {\r\n                                    this.direction = Direction.EAST;\r\n                                    this.incX(moveAmount); // Must go towards PacMan.\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    moved = true;\r\n                }\r\n\r\n                // If PacMan has a clear shot to us in our column, try to go\r\n                // in a direction other than towards PacMan.\r\n                else if (col === pacCol && maze.isClearShotColumn(col, row, pacRow)) {\r\n                    if (!this.goLeftIfPossible(maze, moveAmount)) {\r\n                        if (!this.goRightIfPossible(maze, moveAmount)) {\r\n                            if (pacRow < row) { // PacMan is above us.\r\n                                if (!this.goDownIfPossible(maze, moveAmount)) {\r\n                                    this.direction = Direction.NORTH;\r\n                                    this.incY(-moveAmount); // Must go towards PacMan.\r\n                                }\r\n                            }\r\n                            else { // PacMan is below us.\r\n                                if (!this.goUpIfPossible(maze, moveAmount)) {\r\n                                    this.direction = Direction.SOUTH;\r\n                                    this.incY(moveAmount); // Must go towards PacMan.\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    moved = true;\r\n                }\r\n\r\n                if (!moved) {\r\n                    this.changeDirectionFallback(maze);\r\n                }\r\n\r\n            }\r\n\r\n            // Not at an intersection, so we should be able to keep going\r\n            // in our current direction.\r\n            else {\r\n                this.continueInCurrentDirection(moveAmount);\r\n            }\r\n\r\n            // Use game.playTime to ensure proper exit delay, even if game is\r\n            // paused, etc.\r\n            if (game.playTime >= this.exitBlueTime) {\r\n                this.motionState = this._previousState;\r\n            }\r\n\r\n        }\r\n\r\n        /**\r\n         * Updates this ghost's position when they are chasing PacMan.\r\n         *\r\n         * @param maze The maze in which the actor is moving.\r\n         */\r\n        abstract updatePositionChasingPacman(maze: Maze): void;\r\n\r\n        /**\r\n         * Updates this ghost's position when it is a set of \"eyes\" heading back\r\n         * to the penalty box.\r\n         *\r\n         * @param maze The maze in which the ghost is moving.\r\n         */\r\n        private _updatePositionEyes(maze: Maze) {\r\n\r\n            // Logic:\r\n            // At intersections, do a breadth-first search to find the shortest\r\n            // path to the penalty box, and head in that direction.\r\n\r\n            let moveAmount: number = this.moveAmount;\r\n\r\n            if (this.atIntersection(maze)) {\r\n\r\n                // NOTE: game.PENALTY_BOX_X is actually in-between two columns, so we\r\n                // pick the \"farther\" one to travel to, so we can be sure that\r\n                // the ghost will always enter the box correctly.\r\n\r\n                let fromRow: number = this.row;\r\n                let fromCol: number = this.column;\r\n                let toRow: number = Math.floor((game.PENALTY_BOX_EXIT_Y + 8) / PacmanGame.TILE_SIZE); // yToRow(game.PENALTY_BOX_EXIT_Y);\r\n                let toCol: number = Math.floor((game.PENALTY_BOX_EXIT_X) / PacmanGame.TILE_SIZE); //xToColumn(game.PENALTY_BOX_EXIT_X);\r\n                if (fromCol <= toCol) {\r\n                    toCol++; // Approaching from the left.\r\n                }\r\n\r\n                let node: MazeNode = maze.getPathBreadthFirst(fromRow, fromCol, toRow, toCol);\r\n                if (node == null) { // i.e. ghost is actually at the penalty box.\r\n                    // Should never happen; we should always catch the ghost\r\n                    // before getting to its destination in the \"else\" below.\r\n                    this.motionState = MotionState.EYES_ENTERING_BOX;\r\n                }\r\n                else {\r\n                    if (node.col < fromCol) {\r\n                        this.direction = Direction.WEST;\r\n                        this.incX(-moveAmount);\r\n                    }\r\n                    else if (node.col > fromCol) {\r\n                        this.direction = Direction.EAST;\r\n                        this.incX(moveAmount);\r\n                    }\r\n                    else if (node.row < fromRow) {\r\n                        this.direction = Direction.NORTH;\r\n                        this.incY(-moveAmount);\r\n                    }\r\n                    else if (node.row > fromRow) {\r\n                        this.direction = Direction.SOUTH;\r\n                        this.incY(moveAmount);\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            // Not at an intersection, so we should be able to keep going\r\n            // in our current direction.\r\n            else {\r\n\r\n                let fromRow: number = this.row;\r\n                let toRow: number = Math.floor((game.PENALTY_BOX_EXIT_Y + 8) / PacmanGame.TILE_SIZE); // yToRow(game.PENALTY_BOX_EXIT_Y);\r\n\r\n                if (fromRow === toRow && this.x === game.PENALTY_BOX_EXIT_X) {\r\n                    this.motionState = MotionState.EYES_ENTERING_BOX;\r\n                }\r\n                else {\r\n                    this.continueInCurrentDirection(moveAmount);\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        /**\r\n         * Updates this ghost's position when it is a set of \"eyes\" re-entering\r\n         * the penalty box.\r\n         *\r\n         * @param maze The maze in which the ghost is moving.\r\n         */\r\n        private _updatePositionEyesEnteringBox(maze: Maze) {\r\n\r\n            let moveAmount: number = GHOST_IN_BOX_SPEED; //getMoveAmount();\r\n\r\n            let y: number = this.y;\r\n            if (y < game.PENALTY_BOX_EXIT_Y + 3 * PacmanGame.SPRITE_SIZE / 2) {\r\n                this.direction = Direction.SOUTH; // May be redundant.\r\n                this.incY(moveAmount);\r\n            }\r\n            else {\r\n                this.motionState = MotionState.LEAVING_BOX;\r\n            }\r\n\r\n        }\r\n\r\n        /**\r\n         * Updates a ghost's position according to its AI.\r\n         *\r\n         * @param maze The maze in which the ghost is floating.\r\n         */\r\n        updatePositionImpl(maze: Maze) {\r\n\r\n            switch (this._motionState) {\r\n                case MotionState.IN_BOX:\r\n                    this.updatePositionInBox(maze);\r\n                    break;\r\n                case MotionState.LEAVING_BOX:\r\n                    this.updatePositionLeavingBox(maze);\r\n                    break;\r\n                case MotionState.SCATTERING:\r\n                    this.updatePositionScattering(maze);\r\n                    break;\r\n                case MotionState.CHASING_PACMAN:\r\n                    this.updatePositionChasingPacman(maze);\r\n                    break;\r\n                case MotionState.BLUE:\r\n                    this._updatePositionBlue(maze);\r\n                    break;\r\n                case MotionState.EYES:\r\n                    this._updatePositionEyes(maze);\r\n                    break;\r\n                case MotionState.EYES_ENTERING_BOX:\r\n                    this._updatePositionEyesEnteringBox(maze);\r\n                    break;\r\n            }\r\n\r\n        }\r\n\r\n        /**\r\n         * Updates an actor's position.\r\n         *\r\n         * @param maze The maze in which the actor is moving.\r\n         */\r\n        updatePositionInBox(maze: Maze) {\r\n\r\n            let moveAmount: number = GHOST_IN_BOX_SPEED; //ghost.getMoveAmount();\r\n\r\n            switch (this.direction) {\r\n                case Direction.WEST: // Never happens\r\n                case Direction.NORTH:\r\n                    if (this.y > 112) {\r\n                        this.incY(-moveAmount);\r\n                    }\r\n                    else {\r\n                        this.direction = Direction.SOUTH;\r\n                    }\r\n                    break;\r\n                case Direction.EAST: // Never happens\r\n                case Direction.SOUTH:\r\n                    if (this.y < 120) {\r\n                        this.incY(moveAmount);\r\n                    }\r\n                    else {\r\n                        this.direction = Direction.NORTH;\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            // Use game.playTime to ensure proper exit delay, even if game is\r\n            // paused, etc.\r\n            if (game.playTime >= this._getFirstExitDelayMillis()) {\r\n                this.motionState = MotionState.LEAVING_BOX;\r\n            }\r\n\r\n        }\r\n\r\n        /**\r\n         * Updates an actor's position.\r\n         *\r\n         * @param maze The maze in which the actor is moving.\r\n         */\r\n        updatePositionLeavingBox(maze: Maze) {\r\n\r\n            let moveAmount: number = GHOST_IN_BOX_SPEED; //getMoveAmount();\r\n\r\n            let x: number = this.x;\r\n            if (x < game.PENALTY_BOX_EXIT_X) {\r\n                this.direction = Direction.EAST; // May be redundant\r\n                this.incX(moveAmount);\r\n            }\r\n            else if (x > game.PENALTY_BOX_EXIT_X) {\r\n                this.direction = Direction.WEST; // May be redundant\r\n                this.incX(-moveAmount);\r\n            }\r\n            else {\r\n                let y: number = this.y - moveAmount;\r\n                this.y = y;\r\n                // \"<=\" instead of \"===\" just in case we have rounding errors (which we\r\n                // shouldn't, but still)\r\n                if (y <= game.PENALTY_BOX_EXIT_Y) {\r\n                    y = game.PENALTY_BOX_EXIT_Y; // Should be unnecessary\r\n                    this.motionState = MotionState.SCATTERING;\r\n                    this.direction = Direction.WEST;\r\n                }\r\n                else {\r\n                    this.direction = Direction.NORTH; // May be redundant\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        /**\r\n         * Updates an actor's position.\r\n         *\r\n         * @param maze The maze in which the actor is moving.\r\n         */\r\n        updatePositionScattering(maze: Maze) {\r\n\r\n            // Logic:\r\n            // At intersections, do a breadth-first search to find the shortest\r\n            // path to our corner, and head in that direction.\r\n\r\n            let moveAmount: number = this.moveAmount;\r\n\r\n            if (this.atIntersection(maze)) {\r\n\r\n                let fromRow: number = this.row;\r\n                let fromCol: number = this.column;\r\n                let toRow: number = this._corner.x;\r\n                let toCol: number = this._corner.y;\r\n                let node: MazeNode = maze.getPathBreadthFirst(fromRow, fromCol, toRow, toCol);\r\n                if (!node) { // i.e. ghost is actually in the corner.\r\n                    this.changeDirectionFallback(maze);\r\n                }\r\n                else {\r\n                    if (node.col < fromCol) {\r\n                        this.direction = Direction.WEST;\r\n                        this.incX(-moveAmount);\r\n                    }\r\n                    else if (node.col > fromCol) {\r\n                        this.direction = Direction.EAST;\r\n                        this.incX(moveAmount);\r\n                    }\r\n                    else if (node.row < fromRow) {\r\n                        this.direction = Direction.NORTH;\r\n                        this.incY(-moveAmount);\r\n                    }\r\n                    else if (node.row > fromRow) {\r\n                        this.direction = Direction.SOUTH;\r\n                        this.incY(moveAmount);\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            // Not at an intersection, so we should be able to keep going\r\n            // in our current direction.\r\n            else {\r\n                this.continueInCurrentDirection(moveAmount);\r\n            }\r\n\r\n            if (game.playTime >= this._exitScatteringTime) {\r\n                this.motionState = MotionState.CHASING_PACMAN;\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n}\r\n"]}