{"version":3,"sources":["pacman/Ghost.ts"],"names":["pacman","pacman.MotionState","pacman.Ghost","pacman.Ghost.constructor","pacman.Ghost.changeDirectionFallback","pacman.Ghost.continueInCurrentDirection","pacman.Ghost._getBlueTimeForLevel","pacman.Ghost._getFirstExitDelayMillis","pacman.Ghost.getFrameCount","pacman.Ghost.motionState","pacman.Ghost.getUpdateDelayMillis","pacman.Ghost.isBlue","pacman.Ghost.isEyes","pacman.Ghost.paint","pacman.Ghost.possiblyTurnBlue","pacman.Ghost.reset","pacman.Ghost.setCorner","pacman.Ghost._updatePositionBlue","pacman.Ghost._updatePositionEyes","pacman.Ghost._updatePositionEyesEnteringBox","pacman.Ghost.updatePositionImpl","pacman.Ghost.updatePositionInBox","pacman.Ghost.updatePositionLeavingBox","pacman.Ghost.updatePositionScattering"],"mappings":";;;;;AAAA,IAAO,MAAM,CA0vBZ;AA1vBD,WAAO,QAAM,EAAC,CAAC;IACXA,YAAYA,CAACA;IAEbA,IAAMA,kBAAkBA,GAAWA,GAAGA,CAACA;IAEvCA,WAAYA,WAAWA;QACnBC,iDAAUA,CAAAA;QACVA,2DAAeA,CAAAA;QACfA,iEAAkBA,CAAAA;QAClBA,yDAAcA,CAAAA;QACdA,6CAAQA,CAAAA;QACRA,6CAAQA,CAAAA;QACRA,uEAAqBA,CAAAA;IACzBA,CAACA,EARWD,oBAAWA,KAAXA,oBAAWA,QAQtBA;IARDA,IAAYA,WAAWA,GAAXA,oBAQXA,CAAAA;IAEDA;QAAoCE,yBAAWA;QA6D3CA,eAAYA,IAAgBA,EAAEA,YAAoBA,EAAEA,gBAAwBA;YACxEC,kBAAMA,CAACA,CAACA,CAACA;YACTA,IAAIA,CAACA,IAAIA,GAAGA,IAAIA,CAACA;YACjBA,IAAIA,CAACA,OAAOA,GAAGA,IAAIA,GAAGA,CAACA,KAAKA,EAAEA,CAACA;YAC/BA,IAAIA,CAACA,aAAaA,GAAGA,YAAYA,CAACA;YAClCA,IAAIA,CAACA,iBAAiBA,GAAGA,gBAAgBA,CAACA;YAC1CA,IAAIA,CAACA,KAAKA,EAAEA,CAACA;QACjBA,CAACA;QAEDD,uCAAuBA,GAAvBA,UAAwBA,IAAUA;YAE9BE,IAAMA,UAAUA,GAAWA,IAAIA,CAACA,UAAUA,CAACA;YAC3CA,IAAMA,IAAIA,GAAWA,GAAGA,CAACA,KAAKA,CAACA,SAASA,CAACA,CAACA,CAACA,CAACA;YAE5CA,MAAMA,CAACA,CAACA,IAAIA,CAACA,CAACA,CAACA;gBAEXA,KAAKA,CAACA;oBACFA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,cAAcA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA,CAACA,CAACA;wBACzCA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,gBAAgBA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA,CAACA,CAACA;4BAC3CA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,iBAAiBA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA,CAACA,CAACA;gCAC5CA,IAAIA,CAACA,gBAAgBA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA;4BAC5CA,CAACA;wBACLA,CAACA;oBACLA,CAACA;oBACDA,KAAKA,CAACA;gBAEVA,KAAKA,CAACA;oBACFA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,gBAAgBA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA,CAACA,CAACA;wBAC3CA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,cAAcA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA,CAACA,CAACA;4BACzCA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,gBAAgBA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA,CAACA,CAACA;gCAC3CA,IAAIA,CAACA,iBAAiBA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA;4BAC7CA,CAACA;wBACLA,CAACA;oBACLA,CAACA;oBACDA,KAAKA,CAACA;gBAEVA,KAAKA,CAACA;oBACFA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,gBAAgBA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA,CAACA,CAACA;wBAC3CA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,gBAAgBA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA,CAACA,CAACA;4BAC3CA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,iBAAiBA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA,CAACA,CAACA;gCAC5CA,IAAIA,CAACA,cAAcA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA;4BAC1CA,CAACA;wBACLA,CAACA;oBACLA,CAACA;oBACDA,KAAKA,CAACA;gBAEVA,KAAKA,CAACA;oBACFA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,iBAAiBA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA,CAACA,CAACA;wBAC5CA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,cAAcA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA,CAACA,CAACA;4BACzCA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,gBAAgBA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA,CAACA,CAACA;gCAC3CA,IAAIA,CAACA,gBAAgBA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA;4BAC5CA,CAACA;wBACLA,CAACA;oBACLA,CAACA;oBACDA,KAAKA,CAACA;YACdA,CAACA;QAELA,CAACA;QAEDF;;;;WAIGA;QACHA,0CAA0BA,GAA1BA,UAA2BA,UAAkBA;YACzCG,MAAMA,CAACA,CAACA,IAAIA,CAACA,SAASA,CAACA,CAACA,CAACA;gBACrBA,KAAKA,kBAASA,CAACA,KAAKA;oBAChBA,IAAIA,CAACA,IAAIA,CAACA,CAACA,UAAUA,CAACA,CAACA;oBACvBA,KAAKA,CAACA;gBACVA,KAAKA,kBAASA,CAACA,IAAIA;oBACfA,IAAIA,CAACA,IAAIA,CAACA,CAACA,UAAUA,CAACA,CAACA;oBACvBA,KAAKA,CAACA;gBACVA,KAAKA,kBAASA,CAACA,KAAKA;oBAChBA,IAAIA,CAACA,IAAIA,CAACA,UAAUA,CAACA,CAACA;oBACtBA,KAAKA,CAACA;gBACVA,KAAKA,kBAASA,CAACA,IAAIA;oBACfA,IAAIA,CAACA,IAAIA,CAACA,UAAUA,CAACA,CAACA;oBACtBA,KAAKA,CAACA;YACdA,CAACA;QACLA,CAACA;QAEDH;;;;;;WAMGA;QACKA,oCAAoBA,GAA5BA,UAA6BA,KAAaA;YACtCI,MAAMA,CAACA,CAACA,KAAKA,CAACA,CAACA,CAACA;gBACZA,KAAKA,CAACA,CAACA;gBACPA,KAAKA,CAACA;oBACFA,MAAMA,CAACA,IAAIA,CAACA;gBAChBA,KAAKA,CAACA,CAACA;gBACPA,KAAKA,CAACA;oBACFA,MAAMA,CAACA,IAAIA,CAACA;gBAChBA,KAAKA,CAACA,CAACA;gBACPA,KAAKA,CAACA;oBACFA,MAAMA,CAACA,IAAIA,CAACA;gBAChBA,KAAKA,CAACA,CAACA;gBAC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;oBAClEA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,gBAAgBA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA,CAACA,CAACA;wBAC3CA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,iBAAiBA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA,CAACA,CAACA;4BAC5CA,EAAEA,CAACA,CAACA,MAAMA,GAAGA,GAAGA,CAACA,CAACA,CAACA;gCACfA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,gBAAgBA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA,CAACA,CAACA;oCAC3CA,IAAIA,CAACA,SAASA,GAAGA,kBAASA,CAACA,KAAKA,CAACA;oCACjCA,IAAIA,CAACA,IAAIA,CAACA,CAACA,UAAUA,CAACA,CAACA,CAACA,0BAA0BA;gCACtDA,CAACA;4BACLA,CAACA;4BACDA,IAAIA,CAACA,CAACA;gCACFA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,cAAcA,CAACA,IAAIA,EAAEA,UAAUA,CAACA,CAACA,CAACA,CAACA;oCACzCA,IAAIA,CAACA,SAASA,GAAGA,kBAASA,CAACA,KAAKA,CAACA;oCACjCA,IAAIA,CAACA,IAAIA,CAACA,UAAUA,CAACA,CAACA,CAACA,0BAA0BA;gCACrDA,CAACA;4BACLA,CAACA;wBACLA,CAACA;oBACLA,CAACA;oBACDA,KAAKA,GAAGA,IAAIA,CAACA;gBACjBA,CAACA;gBAEDA,EAAEA,CAACA,CAACA,CAACA,KAAKA,CAACA,CAACA,CAACA;oBACTA,IAAIA,CAACA,uBAAuBA,CAACA,IAAIA,CAACA,CAACA;gBACvCA,CAACA;YAELA,CAACA;YAIDA,IAAIA,CAACA,CAACA;gBACFA,IAAIA,CAACA,0BAA0BA,CAACA,UAAUA,CAACA,CAACA;YAChDA,CAACA;YAEDA,iEAAiEA;YACjEA,eAAeA;YACfA,EAAEA,CAACA,CAACA,IAAIA,CAACA,QAAQA,IAAIA,IAAIA,CAACA,YAAYA,CAACA,CAACA,CAACA;gBACrCA,IAAI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AIA,CAACA,CAACA;oBAC/BA,KAAKA,CAACA;gBACVA,KAAKA,WAAWA,CAACA,IAAIA;oBACjBA,IAAIA,CAACA,mBAAmBA,CAACA,IAAIA,CAACA,CAACA;oBAC/BA,KAAKA,CAACA;gBACVA,KAAKA,WAAWA,CAACA,iBAAiBA;oBAC9BA,IAAIA,CAACA,8BAA8BA,CAACA,IAAIA,CAACA,CAACA;oBAC1CA,KAAKA,CAACA;YACdA,CAACA;QAELA,CAACA;QAGDlB;;;;WAIGA;QACHA,mCAAmBA,GAAnBA,UAAoBA,IAAUA;YAE1BmB,IAAIA,UAAUA,GAAWA,kBAAkBA,CAACA,CAACA,wBAAwBA;YAErEA,MAAMA,CAACA,CAACA,IAAIA,CAACA,SAASA,CAACA,CAACA,CAACA;gBACrBA,KAAKA,kBAASA,CAACA,IAAIA,CAACA,CAACA,gBAAgBA;gBACrCA,KAAKA,kBAASA,CAACA,KAAKA;oBAChBA,EAAEA,CAACA,CAACA,IAAIA,CAACA,CAACA,GAAGA,GAAGA,CAACA,CAACA,CAACA;wBACfA,IAAIA,CAACA,IAAIA,CAACA,CAACA,UAAUA,CAACA,CAACA;oBAC3BA,CAACA;oBACDA,IAAIA,CAACA,CAACA;wBACFA,IAAIA,CAACA,SAASA,GAAGA,kBAASA,CAACA,KAAKA,CAACA;oBACrCA,CAACA;oBACDA,KAAKA,CAACA;gBACVA,KAAKA,kBAASA,CAACA,IAAIA,CAACA,CAACA,gBAAgBA;gBACrCA,KAAKA,kBAASA,CAACA,KAAKA;oBAChBA,EAAEA,CAACA,CAACA,IAAIA,CAACA,CAACA,GAAGA,GAAGA,CAACA,CAACA,CAACA;wBACfA,IAAIA,CAACA,IAAIA,CAACA,UAAUA,CAACA,CAACA;oBAC1BA,CAACA;oBACDA,IAAIA,CAACA,CAACA;wBACFA,IAAIA,CAACA,SAASA,GAAGA,kBAASA,CAACA,KAAKA,CAACA;oBACrCA,CAACA;oBACDA,KAAKA,CAACA;YACdA,CAACA;YAEDA,iEAAiEA;YACjEA,eAAeA;YACfA,EAAEA,CAACA,CAACA,IAAIA,CAACA,QAAQA,IAAIA,I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","file":"pacman/Ghost.js","sourcesContent":["module pacman {\r\n    'use strict';\r\n\r\n    const GHOST_IN_BOX_SPEED: number = 0.5;\r\n\r\n    export enum MotionState {\r\n        IN_BOX = 0,\r\n        LEAVING_BOX = 1,\r\n        CHASING_PACMAN = 2,\r\n        SCATTERING = 3,\r\n        BLUE = 4,\r\n        EYES = 5,\r\n        EYES_ENTERING_BOX = 6\r\n    }\r\n\r\n    export abstract class Ghost extends _BaseSprite {\r\n\r\n        /**\r\n         * TODO: Remove the need for this variable!  Yucky!\r\n         */\r\n        game: PacmanGame;\r\n\r\n        /**\r\n         * The ghost's current motion state.\r\n         */\r\n        private _motionState: MotionState;\r\n\r\n        /**\r\n         * The \"corner\" this ghost will retreat to when in \"scatter\" mode.\r\n         */\r\n        private _corner: gtp.Point;\r\n\r\n        /**\r\n         * The number of times this ghost has been in \"scatter\" mode for this\r\n         * level and PacMan life.\r\n         */\r\n        private _scatterCount: number;\r\n\r\n        /**\r\n         * If in scatter mode, this is the time at which the mode should switch\r\n         * to \"chasing PacMan\" mode.  If not in scatter mode, this value is\r\n         * invalid.\r\n         */\r\n        private _exitScatteringTime: number;\r\n\r\n        /**\r\n         * The time at which this ghost should switch from \"chasing PacMan\" mode\r\n         * to scatter mode.  If not in the \"chasing PacMan\" motion state,\r\n         * this value is invalid.\r\n         */\r\n        startScatteringTime: number;\r\n\r\n        /**\r\n         * The time at which a ghost should switch from \"blue mode\" to their\r\n         * previous state (chasing PacMan or scattering).  If not in the \"blue\"\r\n         * motion state, this value is invalid.\r\n         */\r\n        exitBlueTime: number;\r\n\r\n        /**\r\n         * The motion state to revert back to when a ghost leaves \"blue mode.\"\r\n         * If a ghost is not in \"blue mode,\" this value is invalid.\r\n         */\r\n        private _previousState: number;\r\n\r\n        /**\r\n         * The y-coordinate of the sprites in the sprite sheet to use.\r\n         */\r\n        private _spriteSheetY: number;\r\n\r\n        /**\r\n         * The number of seconds this ghost will wait before leaving the penalty\r\n         * box for the first time.\r\n         */\r\n        private _exitDelaySeconds: number;\r\n\r\n        constructor(game: PacmanGame, spriteSheetY: number, exitDelaySeconds: number) {\r\n            super(2);\r\n            this.game = game;\r\n            this._corner = new gtp.Point();\r\n            this._spriteSheetY = spriteSheetY;\r\n            this._exitDelaySeconds = exitDelaySeconds;\r\n            this.reset();\r\n        }\r\n\r\n        changeDirectionFallback(maze: Maze) {\r\n\r\n            const moveAmount: number = this.moveAmount;\r\n            const temp: number = gtp.Utils.randomInt(4);\r\n\r\n            switch (temp) {\r\n\r\n                case 0:\r\n                    if (!this.goUpIfPossible(maze, moveAmount)) {\r\n                        if (!this.goLeftIfPossible(maze, moveAmount)) {\r\n                            if (!this.goRightIfPossible(maze, moveAmount)) {\r\n                                this.goDownIfPossible(maze, moveAmount);\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n\r\n                case 1:\r\n                    if (!this.goLeftIfPossible(maze, moveAmount)) {\r\n                        if (!this.goUpIfPossible(maze, moveAmount)) {\r\n                            if (!this.goDownIfPossible(maze, moveAmount)) {\r\n                                this.goRightIfPossible(maze, moveAmount);\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n\r\n                case 2:\r\n                    if (!this.goDownIfPossible(maze, moveAmount)) {\r\n                        if (!this.goLeftIfPossible(maze, moveAmount)) {\r\n                            if (!this.goRightIfPossible(maze, moveAmount)) {\r\n                                this.goUpIfPossible(maze, moveAmount);\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n\r\n                case 3:\r\n                    if (!this.goRightIfPossible(maze, moveAmount)) {\r\n                        if (!this.goUpIfPossible(maze, moveAmount)) {\r\n                            if (!this.goDownIfPossible(maze, moveAmount)) {\r\n                                this.goLeftIfPossible(maze, moveAmount);\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n\r\n        }\r\n\r\n        /**\r\n         * Moves this ghost in its current direction by the specified amount.\r\n         *\r\n         * @param {number} moveAmount The amount to move.\r\n         */\r\n        continueInCurrentDirection(moveAmount: number) {\r\n            switch (this.direction) {\r\n                case Direction.NORTH:\r\n                    this.incY(-moveAmount);\r\n                    break;\r\n                case Direction.WEST:\r\n                    this.incX(-moveAmount);\r\n                    break;\r\n                case Direction.SOUTH:\r\n                    this.incY(moveAmount);\r\n                    break;\r\n                case Direction.EAST:\r\n                    this.incX(moveAmount);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns the length of play time a ghost should stay blue, in\r\n         * milliseconds.\r\n         *\r\n         * @param {number} level The current game level.\r\n         * @return {numbe} The length of time a ghost should stay blue.\r\n         */\r\n        private _getBlueTimeForLevel(level: number): number {\r\n            switch (level) {\r\n                case 0:\r\n                case 1:\r\n                    return 8000;\r\n                case 2:\r\n                case 3:\r\n                    return 6000;\r\n                case 4:\r\n                case 5:\r\n                    return 4000;\r\n                case 6:\r\n                case 7:\r\n                    return 2000;\r\n                default:\r\n                    return 0;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns the amount of time, in milliseconds, that this ghost will wait\r\n         * for before leaving the penalty box for the first time.\r\n         *\r\n         * @return {number} The delay, in milliseconds.\r\n         */\r\n        private _getFirstExitDelayMillis(): number {\r\n            return this._exitDelaySeconds * 1000;\r\n        }\r\n\r\n        getFrameCount(): number {\r\n            return 2;\r\n        }\r\n\r\n        get motionState(): MotionState {\r\n            return this._motionState;\r\n        }\r\n\r\n        /**\r\n         * Returns the number of milliseconds that should pass between the times\r\n         * this ghost moves.  This value is dependant on the ghost's current\r\n         * state.\r\n         *\r\n         * @return The update delay, in milliseconds.\r\n         */\r\n        getUpdateDelayMillis(): number {\r\n            switch (this._motionState) {\r\n                case MotionState.BLUE:\r\n                    return 25;\r\n                case MotionState.EYES:\r\n                case MotionState.EYES_ENTERING_BOX:\r\n                    return 10;\r\n                default: // Chasing PacMan, in penalty box, etc.\r\n                    return 10;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns whether this ghost is in a \"blue\" motion state.\r\n         *\r\n         * @return {boolean} Whether this ghost is blue.\r\n         * @see #isEyes()\r\n         */\r\n        isBlue(): boolean {\r\n            return this._motionState === MotionState.BLUE;\r\n        }\r\n\r\n        /**\r\n         * Returns whether this ghost is in a \"eyes\" motion state.\r\n         *\r\n         * @return Whether this ghost is in an \"eyes\" state.\r\n         * @see #isBlue()\r\n         */\r\n        isEyes(): boolean {\r\n            return this._motionState === MotionState.EYES ||\r\n                this._motionState === MotionState.EYES_ENTERING_BOX;\r\n        }\r\n\r\n        /**\r\n         * Paints this sprite at its current location.\r\n         *\r\n         * @param {CanvasRenderingContext2D} ctx The rendering context to use.\r\n         */\r\n        paint(ctx: CanvasRenderingContext2D) {\r\n\r\n            let destX: number = this.bounds.x;\r\n            let destY: number = this.bounds.y;\r\n            let SPRITE_SIZE: number = PacmanGame.SPRITE_SIZE;\r\n            let srcX: number,\r\n                srcY: number;\r\n\r\n            switch (this._motionState) {\r\n\r\n                case MotionState.BLUE:\r\n                    srcX = (10 + this.getFrame()) * SPRITE_SIZE;\r\n                    srcY = 3 * SPRITE_SIZE;\r\n                    let playTime: number = game.playTime;\r\n                    if ((this.exitBlueTime - playTime) <= 1000) { // 1 sec. remaining\r\n                        if (((playTime / 250) & 1) !== 0) {\r\n                            srcY += SPRITE_SIZE; // Flash 4 times in last second\r\n                        }\r\n                    }\r\n                    game.drawSprite(destX, destY, srcX, srcY);\r\n                    break;\r\n\r\n                case MotionState.EYES:\r\n                case MotionState.EYES_ENTERING_BOX:\r\n                    srcX = this.direction * SPRITE_SIZE;\r\n                    srcY = 4 * SPRITE_SIZE;\r\n                    game.drawSprite(destX, destY, srcX, srcY);\r\n                    break;\r\n\r\n                default:\r\n                    srcX = this.direction * SPRITE_SIZE * this.getFrameCount() +\r\n                        this.getFrame() * SPRITE_SIZE;\r\n                    srcY = this._spriteSheetY;\r\n                    game.drawSprite(destX, destY, srcX, srcY);\r\n                    break;\r\n\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Turns this ghost \"blue,\" if it is not in the penalty box and is not\r\n         * currently floating eyes.\r\n         */\r\n        possiblyTurnBlue(): boolean {\r\n            switch (this._motionState) {\r\n                case MotionState.CHASING_PACMAN:\r\n                case MotionState.SCATTERING:\r\n                case MotionState.BLUE:\r\n                    this.motionState = MotionState.BLUE;\r\n                    return true;\r\n                default:\r\n                    // Do nothing; in other states, we don't turn blue.\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Resets the ghost's internal state so that:\r\n         *\r\n         * <ol>\r\n         *    <li>It is in the penalty box (except for Blinky).\r\n         *    <li>It's no longer blinking.\r\n         *    <li>Its direction is set appropriately.\r\n         * </ol>\r\n         *\r\n         * This method should be called on loading a new level, PacMan dying, etc.\r\n         * Subclasses should be sure to call the super's implementation when\r\n         * overriding.\r\n         */\r\n        reset() {\r\n            super.reset();\r\n            this._scatterCount = 0;\r\n        }\r\n\r\n        /**\r\n         * Sets the coordinates of the \"corner\" this ghost goes to when in scatter\r\n         * mode.\r\n         *\r\n         * @param {gtp.Point} corner The corner to go to.\r\n         */\r\n        setCorner(corner: gtp.Point) {\r\n            this._corner.x = corner.x;\r\n            this._corner.y = corner.y;\r\n        }\r\n\r\n        set motionState(motionState: MotionState) {\r\n\r\n            let game: PacmanGame = this.game;\r\n\r\n            // Ghosts stay in \"scatter mode\" for varying lengths of time:\r\n            // The first (just out of the penalty box) and second times, it lasts\r\n            // for 7 seconds.  The third and fourth times, it lasts for 5 seconds.\r\n            // Ghosts don't enter scatter mode a 5th time; they just relentlessly\r\n            // attack PacMan.\r\n            if (motionState === MotionState.SCATTERING) {\r\n                switch (this._scatterCount++) {\r\n                    case 0:\r\n                    case 1:\r\n                        this._exitScatteringTime = game.playTime + 7000;\r\n                        this._motionState = motionState;\r\n                        break;\r\n                    case 2:\r\n                    case 3:\r\n                        this._exitScatteringTime = game.playTime + 5000;\r\n                        this._motionState = motionState;\r\n                        break;\r\n                    default:\r\n                        this._motionState = MotionState.CHASING_PACMAN;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            else if (motionState === MotionState.BLUE) {\r\n                let blueTime: number  = this._getBlueTimeForLevel(game.level);\r\n                let playTime: number = game.playTime;\r\n                this.exitBlueTime = playTime + blueTime;\r\n                // Remember previous state and modify its \"end time\" to\r\n                // include the blue time.\r\n                switch (this._motionState) {\r\n                    case MotionState.CHASING_PACMAN:\r\n                        this._previousState = this._motionState;\r\n                        this.startScatteringTime += blueTime;\r\n                        break;\r\n                    case MotionState.SCATTERING:\r\n                        this._previousState = this._motionState;\r\n                        this._exitScatteringTime += blueTime;\r\n                        break;\r\n                    case MotionState.BLUE:\r\n                        // Keep previous \"previousState\".\r\n                        let prevBlueTimeRemaining: number = this.exitBlueTime - playTime;\r\n                        switch (this._previousState) {\r\n                            case MotionState.CHASING_PACMAN:\r\n                                this.startScatteringTime += prevBlueTimeRemaining + blueTime;\r\n                                break;\r\n                            case MotionState.SCATTERING:\r\n                                this._exitScatteringTime += prevBlueTimeRemaining + blueTime;\r\n                                break;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        throw  new Error('Unexpected state: ' + this._motionState);\r\n                }\r\n                this._motionState = motionState;\r\n            }\r\n\r\n            // Any states other than \"scatter mode\" and \"blue\" aren't special.\r\n            else {\r\n                if (this._motionState === MotionState.CHASING_PACMAN) {\r\n                    this.startScatteringTime = game.playTime + 20000;\r\n                }\r\n                this._motionState = motionState;\r\n            }\r\n\r\n            this.game.checkLoopedSound();\r\n        }\r\n\r\n        /**\r\n         * Updates this ghost's position when they are \"blue.\"\r\n         *\r\n         * @param {Maze} maze The maze in which the ghost is moving.\r\n         */\r\n        _updatePositionBlue(maze: Maze) {\r\n\r\n            // Logic:\r\n            // If PacMan has a clear shot to us, try to go in a direction other\r\n            // than PacMan before resorting to going straight for him.  If\r\n            // PacMan does NOT have a clear shot, just pick a random direction.\r\n\r\n            let moveAmount: number = this.moveAmount;\r\n\r\n            // If we're at an intersection and can change direction...\r\n            if (this.atIntersection(maze)) {\r\n\r\n                let pacman: Pacman = game.pacman;\r\n                let pacRow: number = pacman.row;\r\n                let pacCol: number = pacman.column;\r\n                let row: number = this.row;\r\n                let col: number = this.column;\r\n                let moved: boolean = false;\r\n\r\n                // If PacMan has a straight shot to us in our row, try to go\r\n                // in a direction other than towards PacMan.\r\n                if (row === pacRow && maze.isClearShotRow(row, col, pacCol)) {\r\n                    if (!this.goUpIfPossible(maze, moveAmount)) {\r\n                        if (!this.goDownIfPossible(maze, moveAmount)) {\r\n                            if (pacCol < col) { // PacMan is to our left.\r\n                                if (!this.goRightIfPossible(maze, moveAmount)) {\r\n                                    this.direction = Direction.WEST;\r\n                                    this.incX(-moveAmount); // Must go towards PacMan.\r\n                                }\r\n                            }\r\n                            else { // PacMan is to our right.\r\n                                if (!this.goLeftIfPossible(maze, moveAmount)) {\r\n                                    this.direction = Direction.EAST;\r\n                                    this.incX(moveAmount); // Must go towards PacMan.\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    moved = true;\r\n                }\r\n\r\n                // If PacMan has a clear shot to us in our column, try to go\r\n                // in a direction other than towards PacMan.\r\n                else if (col === pacCol && maze.isClearShotColumn(col, row, pacRow)) {\r\n                    if (!this.goLeftIfPossible(maze, moveAmount)) {\r\n                        if (!this.goRightIfPossible(maze, moveAmount)) {\r\n                            if (pacRow < row) { // PacMan is above us.\r\n                                if (!this.goDownIfPossible(maze, moveAmount)) {\r\n                                    this.direction = Direction.NORTH;\r\n                                    this.incY(-moveAmount); // Must go towards PacMan.\r\n                                }\r\n                            }\r\n                            else { // PacMan is below us.\r\n                                if (!this.goUpIfPossible(maze, moveAmount)) {\r\n                                    this.direction = Direction.SOUTH;\r\n                                    this.incY(moveAmount); // Must go towards PacMan.\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    moved = true;\r\n                }\r\n\r\n                if (!moved) {\r\n                    this.changeDirectionFallback(maze);\r\n                }\r\n\r\n            }\r\n\r\n            // Not at an intersection, so we should be able to keep going\r\n            // in our current direction.\r\n            else {\r\n                this.continueInCurrentDirection(moveAmount);\r\n            }\r\n\r\n            // Use game.playTime to ensure proper exit delay, even if game is\r\n            // paused, etc.\r\n            if (game.playTime >= this.exitBlueTime) {\r\n                this.motionState = this._previousState;\r\n            }\r\n\r\n        }\r\n\r\n\r\n        /**\r\n         * Updates this ghost's position when they are chasing PacMan.\r\n         *\r\n         * @param maze The maze in which the actor is moving.\r\n         */\r\n        abstract updatePositionChasingPacman(maze: Maze): void;\r\n\r\n\r\n        /**\r\n         * Updates this ghost's position when it is a set of \"eyes\" heading back\r\n         * to the penalty box.\r\n         *\r\n         * @param maze The maze in which the ghost is moving.\r\n         */\r\n        private _updatePositionEyes(maze: Maze) {\r\n\r\n            // Logic:\r\n            // At intersections, do a breadth-first search to find the shortest\r\n            // path to the penalty box, and head in that direction.\r\n\r\n            let moveAmount: number = this.moveAmount;\r\n\r\n            if (this.atIntersection(maze)) {\r\n\r\n                // NOTE: game.PENALTY_BOX_X is actually in-between two columns, so we\r\n                // pick the \"farther\" one to travel to, so we can be sure that\r\n                // the ghost will always enter the box correctly.\r\n\r\n                let fromRow: number = this.row;\r\n                let fromCol: number = this.column;\r\n                let toRow: number = Math.floor((game.PENALTY_BOX_EXIT_Y + 8) / PacmanGame.TILE_SIZE); // yToRow(game.PENALTY_BOX_EXIT_Y);\r\n                let toCol: number = Math.floor((game.PENALTY_BOX_EXIT_X) / PacmanGame.TILE_SIZE); //xToColumn(game.PENALTY_BOX_EXIT_X);\r\n                if (fromCol <= toCol) {\r\n                    toCol++; // Approaching from the left.\r\n                }\r\n\r\n                let node: MazeNode = maze.getPathBreadthFirst(fromRow, fromCol, toRow, toCol);\r\n                if (node == null) { // i.e. ghost is actually at the penalty box.\r\n                    // Should never happen; we should always catch the ghost\r\n                    // before getting to its destination in the \"else\" below.\r\n                    this.motionState = MotionState.EYES_ENTERING_BOX;\r\n                }\r\n                else {\r\n                    if (node.col < fromCol) {\r\n                        this.direction = Direction.WEST;\r\n                        this.incX(-moveAmount);\r\n                    }\r\n                    else if (node.col > fromCol) {\r\n                        this.direction = Direction.EAST;\r\n                        this.incX(moveAmount);\r\n                    }\r\n                    else if (node.row < fromRow) {\r\n                        this.direction = Direction.NORTH;\r\n                        this.incY(-moveAmount);\r\n                    }\r\n                    else if (node.row > fromRow) {\r\n                        this.direction = Direction.SOUTH;\r\n                        this.incY(moveAmount);\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            // Not at an intersection, so we should be able to keep going\r\n            // in our current direction.\r\n            else {\r\n\r\n                let fromRow: number = this.row;\r\n                let toRow: number = Math.floor((game.PENALTY_BOX_EXIT_Y + 8) / PacmanGame.TILE_SIZE); // yToRow(game.PENALTY_BOX_EXIT_Y);\r\n\r\n                if (fromRow === toRow && this.x === game.PENALTY_BOX_EXIT_X) {\r\n                    this.motionState = MotionState.EYES_ENTERING_BOX;\r\n                }\r\n                else {\r\n                    this.continueInCurrentDirection(moveAmount);\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n        /**\r\n         * Updates this ghost's position when it is a set of \"eyes\" re-entering\r\n         * the penalty box.\r\n         *\r\n         * @param maze The maze in which the ghost is moving.\r\n         */\r\n        private _updatePositionEyesEnteringBox(maze: Maze) {\r\n\r\n            let moveAmount: number = GHOST_IN_BOX_SPEED; //getMoveAmount();\r\n\r\n            let y: number = this.y;\r\n            if (y < game.PENALTY_BOX_EXIT_Y + 3 * PacmanGame.SPRITE_SIZE / 2) {\r\n                this.direction = Direction.SOUTH; // May be redundant.\r\n                this.incY(moveAmount);\r\n            }\r\n            else {\r\n                this.motionState = MotionState.LEAVING_BOX;\r\n            }\r\n\r\n        }\r\n\r\n\r\n        /**\r\n         * Updates a ghost's position according to its AI.\r\n         *\r\n         * @param maze The maze in which the ghost is floating.\r\n         */\r\n        updatePositionImpl(maze: Maze) {\r\n\r\n            switch (this._motionState) {\r\n                case MotionState.IN_BOX:\r\n                    this.updatePositionInBox(maze);\r\n                    break;\r\n                case MotionState.LEAVING_BOX:\r\n                    this.updatePositionLeavingBox(maze);\r\n                    break;\r\n                case MotionState.SCATTERING:\r\n                    this.updatePositionScattering(maze);\r\n                    break;\r\n                case MotionState.CHASING_PACMAN:\r\n                    this.updatePositionChasingPacman(maze);\r\n                    break;\r\n                case MotionState.BLUE:\r\n                    this._updatePositionBlue(maze);\r\n                    break;\r\n                case MotionState.EYES:\r\n                    this._updatePositionEyes(maze);\r\n                    break;\r\n                case MotionState.EYES_ENTERING_BOX:\r\n                    this._updatePositionEyesEnteringBox(maze);\r\n                    break;\r\n            }\r\n\r\n        }\r\n\r\n\r\n        /**\r\n         * Updates an actor's position.\r\n         *\r\n         * @param maze The maze in which the actor is moving.\r\n         */\r\n        updatePositionInBox(maze: Maze) {\r\n\r\n            let moveAmount: number = GHOST_IN_BOX_SPEED; //ghost.getMoveAmount();\r\n\r\n            switch (this.direction) {\r\n                case Direction.WEST: // Never happens\r\n                case Direction.NORTH:\r\n                    if (this.y > 112) {\r\n                        this.incY(-moveAmount);\r\n                    }\r\n                    else {\r\n                        this.direction = Direction.SOUTH;\r\n                    }\r\n                    break;\r\n                case Direction.EAST: // Never happens\r\n                case Direction.SOUTH:\r\n                    if (this.y < 120) {\r\n                        this.incY(moveAmount);\r\n                    }\r\n                    else {\r\n                        this.direction = Direction.NORTH;\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            // Use game.playTime to ensure proper exit delay, even if game is\r\n            // paused, etc.\r\n            if (game.playTime >= this._getFirstExitDelayMillis()) {\r\n                this.motionState = MotionState.LEAVING_BOX;\r\n            }\r\n\r\n        }\r\n\r\n\r\n        /**\r\n         * Updates an actor's position.\r\n         *\r\n         * @param maze The maze in which the actor is moving.\r\n         */\r\n        updatePositionLeavingBox(maze: Maze) {\r\n\r\n            let moveAmount: number = GHOST_IN_BOX_SPEED; //getMoveAmount();\r\n\r\n            let x: number = this.x;\r\n            if (x < game.PENALTY_BOX_EXIT_X) {\r\n                this.direction = Direction.EAST; // May be redundant\r\n                this.incX(moveAmount);\r\n            }\r\n            else if (x > game.PENALTY_BOX_EXIT_X) {\r\n                this.direction = Direction.WEST; // May be redundant\r\n                this.incX(-moveAmount);\r\n            }\r\n            else {\r\n                let y: number = this.y - moveAmount;\r\n                this.y = y;\r\n                // \"<=\" instead of \"===\" just in case we have rounding errors (which we\r\n                // shouldn't, but still)\r\n                if (y <= game.PENALTY_BOX_EXIT_Y) {\r\n                    y = game.PENALTY_BOX_EXIT_Y; // Should be unnecessary\r\n                    this.motionState = MotionState.SCATTERING;\r\n                    this.direction = Direction.WEST;\r\n                }\r\n                else {\r\n                    this.direction = Direction.NORTH; // May be redundant\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n\r\n        /**\r\n         * Updates an actor's position.\r\n         *\r\n         * @param maze The maze in which the actor is moving.\r\n         */\r\n        updatePositionScattering(maze: Maze) {\r\n\r\n            // Logic:\r\n            // At intersections, do a breadth-first search to find the shortest\r\n            // path to our corner, and head in that direction.\r\n\r\n            let moveAmount: number = this.moveAmount;\r\n\r\n            if (this.atIntersection(maze)) {\r\n\r\n                let fromRow: number = this.row;\r\n                let fromCol: number = this.column;\r\n                let toRow: number = this._corner.x;\r\n                let toCol: number = this._corner.y;\r\n                let node: MazeNode = maze.getPathBreadthFirst(fromRow, fromCol, toRow, toCol);\r\n                if (!node) { // i.e. ghost is actually in the corner.\r\n                    this.changeDirectionFallback(maze);\r\n                }\r\n                else {\r\n                    if (node.col < fromCol) {\r\n                        this.direction = Direction.WEST;\r\n                        this.incX(-moveAmount);\r\n                    }\r\n                    else if (node.col > fromCol) {\r\n                        this.direction = Direction.EAST;\r\n                        this.incX(moveAmount);\r\n                    }\r\n                    else if (node.row < fromRow) {\r\n                        this.direction = Direction.NORTH;\r\n                        this.incY(-moveAmount);\r\n                    }\r\n                    else if (node.row > fromRow) {\r\n                        this.direction = Direction.SOUTH;\r\n                        this.incY(moveAmount);\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            // Not at an intersection, so we should be able to keep going\r\n            // in our current direction.\r\n            else {\r\n                this.continueInCurrentDirection(moveAmount);\r\n            }\r\n\r\n            if (game.playTime >= this._exitScatteringTime) {\r\n                this.motionState = MotionState.CHASING_PACMAN;\r\n            }\r\n\r\n        }\r\n\r\n\r\n    }\r\n}\r\n"],"sourceRoot":"/source/"}